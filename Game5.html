<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Magic Survival (Improved Combat & Death)</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<script src="https://aframe.io/releases/1.4.2/aframe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/aframe-physics-system@4.0.1/dist/aframe-physics-system.min.js"></script>
<style>
  html,body{height:100%;margin:0;background:#000;font-family:system-ui,Segoe UI,Roboto,Arial}
  #ui-root{position:absolute;inset:0;z-index:9999;pointer-events:none}
  .ui-clickable, #start-btn, #more-btn, #close-bp, .hotbar-item, button { pointer-events:auto }
  #hud{position:absolute;left:12px;top:12px;color:#fff;width:360px;z-index:10000}
  .label-row{display:flex;justify-content:space-between;font-size:13px}
  .bar-wrap{margin:6px 0;background:rgba(0,0,0,0.55);padding:6px;border-radius:10px;border:1px solid rgba(255,255,255,0.04)}
  .bar{height:14px;border-radius:8px;background:#222;overflow:hidden}
  .fill{height:100%;transition:width .2s}
  .hp-fill{background:linear-gradient(90deg,#ff6a6a,#ff2a2a)}
  .stam-fill{background:linear-gradient(90deg,#7ee7ff,#00b7ff)}
  .mana-fill{background:linear-gradient(90deg,#b28bff,#6b43ff)}
  #hotbar{position:absolute;left:50%;bottom:18px;transform:translateX(-50%);display:flex;gap:10px;padding:10px;border-radius:12px;background:rgba(0,0,0,0.6);border:1px solid rgba(255,255,255,0.06);z-index:10000}
  .hotbar-item{width:56px;height:56px;background:#222;border-radius:8px;display:flex;align-items:center;justify-content:center;border:2px solid #555;cursor:pointer;position:relative;opacity:.55}
  .hotbar-item.active{border-color:#39ffb6;box-shadow:0 0 12px #39ffb6;opacity:1}
  .hotbar-item img{width:36px;height:36px;user-select:none;-webkit-user-drag:none}
  .hotbar-key{position:absolute;bottom:-16px;left:0;right:0;text-align:center;color:#fff;font-size:12px}
  #more-btn{width:40px;height:40px;border-radius:9999px;display:flex;align-items:center;justify-content:center;cursor:pointer;background:rgba(255,255,255,0.03);border:1px solid rgba(255,255,255,0.06);color:#fff;font-size:20px}
  #backpack{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);width:min(92vw,920px);height:min(80vh,520px);background:rgba(6,6,8,0.95);border-radius:12px;color:#fff;padding:12px;display:none;z-index:10010;border:1px solid rgba(255,255,255,0.04)}
  #backpack.open{display:block}
  .inv-grid{display:grid;grid-template-columns:repeat(6,1fr);gap:8px;padding:8px;background:rgba(255,255,255,0.02);border-radius:8px;flex:2;overflow:auto}
  .slot{height:72px;background:#101012;border-radius:8px;display:flex;align-items:center;justify-content:center;position:relative;border:1px solid rgba(255,255,255,0.08);cursor:pointer}
  .slot img { width: 50%; height: 50%; object-fit: contain; }
  .qty{position:absolute;right:6px;bottom:6px;font-size:12px;opacity:0.9}
  .craft-row{display:flex;align-items:center;justify-content:space-between;padding:6px 0;border-bottom:1px dashed rgba(255,255,255,0.06)}
  .craft-left{display:flex;align-items:center;gap:10px}
  .craft-left img{width:28px;height:28px;border-radius:4px}
  #upgrades{position:absolute;left:12px;bottom:14px;background:rgba(0,0,0,0.6);padding:8px;border-radius:10px;border:1px solid rgba(255,255,255,0.05);z-index:10000;color:#fff}
  #state{position:absolute;right:12px;top:12px;background:rgba(0,0,0,0.6);padding:10px;border-radius:10px;color:#fff;border:1px solid rgba(255,255,255,0.06);z-index:10000;width:260px}
  #damage-flash{position:absolute; inset:0;background:rgba(255,0,0,0.12);opacity:0;pointer-events:none;transition:opacity .15s;z-index:10005}
  #prompt{position:absolute;left:50%;top:64%;transform:translateX(-50%);background:rgba(0,0,0,0.6);color:#fff;padding:6px 10px;border-radius:8px;z-index:10005;display:none}
  #infobox{position:absolute;right:12px;bottom:12px;width:300px;background:rgba(0,0,0,0.6);color:#fff;border:1px solid rgba(255,255,255,0.06);border-radius:10px;padding:10px;z-index:10000;max-height:40vh;overflow:auto;font-size:13px}
  #infobox h4{margin:0 0 6px 0;font-size:14px}
  .muted{opacity:.85}
  #intro{position:absolute; inset:0;background:radial-gradient(ellipse at center, rgba(0,0,0,.75), rgba(0,0,0,.95));display:flex;align-items:center;justify-content:center;flex-direction:column;color:#fff;z-index:10050}
  #intro h1{font-size:42px;margin:0 0 8px 0;letter-spacing:1px}
  #intro p{max-width:680px;text-align:center;margin:0 0 16px 0;opacity:.9}
  #start-btn{padding:10px 18px;border-radius:10px;border:1px solid rgba(255,255,255,.2);background:rgba(255,255,255,.1);color:#fff;font-weight:700;cursor:pointer}
  #lock-helper{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);color:#fff;background:rgba(0,0,0,.55);padding:8px 12px;border-radius:8px;font-size:14px;z-index:10006;display:none}
  #build-preview {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(0, 200, 0, 0.3);
    border: 1px dashed white;
    z-index: 10001;
    pointer-events: none;
    display: none;
  }
  #rubybar {
    position: absolute;
    right: 12px;
    top: calc(100% - 78px);
    transform: translateX(0);
    background: rgba(0,0,0,0.6);
    padding: 8px 18px;
    border-radius: 14px;
    border: 1px solid rgba(255,255,255,0.08);
    display: flex;
    align-items: center;
    gap: 12px;
    z-index: 10020;
    font-size: 17px;
    font-weight: 700;
    color: #ffe5ee;
    box-shadow: 0 0 8px #d20080 inset;
  }
  .ruby-icon {
    width: 28px;
    height: 28px;
    vertical-align: middle;
    margin-right: 8px;
  }
  #daytime-bar {
    position: absolute;
    left: 50%;
    top: 8px;
    transform: translateX(-50%);
    background: rgba(0,0,0,0.5);
    color: #ffe;
    padding: 6px 18px;
    font-size: 15px;
    border-radius: 12px;
    border: 1px solid rgba(255,255,255,0.06);
    z-index: 10030;
    font-weight: 700;
    box-shadow: 0 0 6px #ffe inset;
  }
  /* Death overlay */
  #deathOverlay {
    position: absolute;
    inset: 0;
    display: none;
    z-index: 10060;
    align-items: center;
    justify-content: center;
    color: #fff;
    pointer-events: none;
    text-align: center;
    font-size: 20px;
    background: rgba(0,0,0,0.65);
  }
  #deathOverlay .box {
    pointer-events: auto;
    background: rgba(20,0,0,0.6);
    padding: 20px 28px;
    border-radius: 12px;
    border: 1px solid rgba(255,255,255,0.06);
  }
</style>
</head>
<body>
<div id="ui-root">
  <div id="intro">
    <h1>Magic Survival</h1>
    <p>You awaken in the Emerald Vale with <b>nothing</b>. Scrounge sticks, rocks, and mushrooms, craft your first tools, then earn the Elder’s trust. Beware creatures in the wilds—most ignore you unless you strike first.</p>
    <div class="muted" style="margin-bottom:10px">Controls: WASD move · Mouse look (click to lock) · Shift sprint · E pick up · G talk/interact · Left Click attack/place · Right Click fireball · Space jump · B build · C climb</div>
    <button id="start-btn">Start Adventure</button>
  </div>
  <div id="rubybar">
    <img src="https://cdn-icons-png.flaticon.com/128/1997/1997928.png" alt="Ruby" class="ruby-icon">
    Rubies: <span id="rubyCount">0</span>
  </div>
  <div id="daytime-bar">Day</div>
  <div id="hud">
    <div class="label-row"><strong>Level <span id="level">1</span></strong><div>XP <span id="xp">0</span>/<span id="xpMax">100</span></div></div>
    <div style="margin-top:8px" class="label-row"><span>Health</span><span id="hpText">100/100</span></div>
    <div class="bar-wrap"><div class="bar"><div id="hpBar" class="fill hp-fill" style="width:100%"></div></div></div>
    <div class="label-row"><span>Stamina</span><span id="stamText">100/100</span></div>
    <div class="bar-wrap"><div class="bar"><div id="stamBar" class="fill stam-fill" style="width:100%"></div></div></div>
    <div class="label-row"><span>Mana</span><span id="manaText">60/60</span></div>
    <div class="bar-wrap"><div class="bar"><div id="manaBar" class="fill mana-fill" style="width:100%"></div></div></div>
    <div style="margin-top:8px;background:rgba(255,255,255,0.03);padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.03)">
      <div style="font-weight:700">Quest</div>
      <div id="quest">Talk to the Forest Elder</div>
    </div>
  </div>
  <div id="hotbar" role="toolbar" aria-label="Hotbar">
    <div class="hotbar-item" data-item="stone-axe" title="Stone Axe"><img id="hb2" alt=""><div class="hotbar-key">1</div></div>
    <div class="hotbar-item" data-item="wood-staff" title="Wood Staff"><img id="hb3" alt=""><div class="hotbar-key">2</div></div>
    <div id="more-btn" class="ui-clickable" title="Open Backpack">⋯</div>
  </div>
  <div id="backpack">
    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:10px">
      <div style="font-weight:800">Backpack</div>
      <div><button id="close-bp" class="ui-clickable">Close</button></div>
    </div>
    <div style="display:flex;gap:12px;height:calc(100% - 44px)">
      <div class="inv-grid" id="inv-grid" style="flex:2"></div>
      <div style="flex:1;display:flex;flex-direction:column;gap:8px">
        <div style="background:rgba(255,255,255,0.02);padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.03)">
          <div style="font-weight:700;margin-bottom:6px">Crafting</div>
          <div id="craft-list"></div>
        </div>
        <div style="background:rgba(255,255,255,0.02);padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.03)">
          <div id="desc" class="muted">Pick up materials with <b>E</b> to craft. Talk to the Elder with <b>G</b>.</div>
        </div>
      </div>
    </div>
  </div>
  <div id="upgrades">
    <div style="font-weight:700;margin-bottom:6px">Upgrade States (XP)</div>
    <div style="display:flex;gap:6px">
      <button id="up-hp" class="ui-clickable">+HP (50 XP)</button>
      <button id="up-stam" class="ui-clickable">+Stam (30 XP)</button>
      <button id="up-mana" class="ui-clickable">+Mana (30 XP)</button>
    </div>
    <div class="muted" style="margin-top:6px">XP: <span id="xp_small">0</span></div>
  </div>
  <div id="state">
    <div><strong>Equipped:</strong> <span id="equipped">None</span></div>
    <div><strong>Status:</strong> <span id="status">Idle</span></div>
    <div><strong>Hydration:</strong> <span id="hydration">100%</span></div>
    <div><strong>Food:</strong> <span id="food">100%</span></div>
    <div><strong>Enemies Nearby:</strong> <span id="enemyCount">0</span></div>
  </div>
  <div id="infobox">
    <h4>Info</h4>
    <div id="infolog" class="muted"></div>
  </div>
  <div id="damage-flash"></div>
  <div id="prompt" style="display:none;"></div>
  <div id="lock-helper">Click the scene to enable mouse look (Esc to release)</div>
  <div id="build-preview"></div>
  <div id="deathOverlay"><div class="box"><div id="deathText" style="font-size:26px;font-weight:800;margin-bottom:6px">You have died</div><div id="respawnCountdown" style="font-size:18px">Respawning in 4...</div></div></div>
</div>

<a-scene physics="gravity: -9.8" renderer="antialias:true; colorManagement:true" shadow="type:pcfsoft">
  <a-assets>
    <img id="grassTex" src="https://tse3.mm.bing.net/th/id/OIP.wjDgTaxNxEzfCY4cYNiUIwHaEJ?r=0&rs=1&pid=ImgDetMain&o=7&rm=3" crossorigin="anonymous">
    <img id="skyTex"   src="https://tse3.mm.bing.net/th/id/OIP.6Ddp4MLFtuM7DFzkxFTG4AHaE7?r=0&rs=1&pid=ImgDetMain&o=7&rm=3" crossorigin="anonymous">
    <img id="bark"     src="https://tse3.mm.bing.net/th/id/OIP.9-L_yT9IyyNgdNkopIT4PAHaLH?r=0&rs=1&pid=ImgDetMain&o=7&rm=3" crossorigin="anonymous">
    <img id="leaf"     src="https://as2.ftcdn.net/v2/jpg/01/65/68/07/1000_F_165680748_x7HmRDk22UU5DiB4r74mVKVf2gO5mp6a.jpg" crossorigin="anonymous">
    <img id="ruby" src="https://cdn-icons-png.flaticon.com/128/1997/1997928.png" crossorigin="anonymous">
    <img id="villagerImg" src="https://cdn-icons-png.flaticon.com/128/4140/4140048.png" crossorigin="anonymous">
    <img id="houseTex" src="https://st3.depositphotos.com/1000017/15074/i/450/depositphotos_150742104-stock-photo-wooden-house.jpg" crossorigin="anonymous">
    <!-- Placeholder icons for inventory items -->
    <img id="icon-stick" src="https://img.icons8.com/ios-glyphs/90/000000/stick.png" crossorigin="anonymous">
    <img id="icon-rock" src="https://img.icons8.com/ios-glyphs/90/000000/rock.png" crossorigin="anonymous">
    <img id="icon-mushroom" src="https://img.icons8.com/ios-glyphs/90/000000/mushroom.png" crossorigin="anonymous">
    <img id="icon-potion" src="https://img.icons8.com/ios-glyphs/90/000000/potion.png" crossorigin="anonymous">
    <img id="icon-water" src="https://img.icons8.com/ios-glyphs/90/000000/water-bottle.png" crossorigin="anonymous">
    <img id="icon-wood-staff" src="https://img.icons8.com/ios-filled/90/000000/wizard-staff.png" crossorigin="anonymous">
    <img id="icon-stone-axe" src="https://img.icons8.com/ios-glyphs/90/000000/axe.png" crossorigin="anonymous">
    <img id="icon-planks" src="https://img.icons8.com/ios-glyphs/90/000000/wood.png" crossorigin="anonymous">
    <img id="icon-house" src="https://img.icons8.com/ios-filled/90/000000/house.png" crossorigin="anonymous">
    <img id="icon-ruby" src="https://cdn-icons-png.flaticon.com/128/1997/1997928.png" crossorigin="anonymous">
    <img id="icon-ruby-necklace" src="https://cdn-icons-png.flaticon.com/512/1049/1049753.png" crossorigin="anonymous">
  </a-assets>
  <a-entity light="type:ambient; color:#bbb; intensity:0.8" id="ambientLight"></a-entity>
  <a-entity light="type:directional; intensity:1" position="5 12 -3" rotation="-45 30 0" shadow="cast:true"></a-entity>
  <a-plane id="ground" src="#grassTex" rotation="-90 0 0" width="240" height="240"
           material="repeat: 100 100; roughness: 1" shadow="receive:true" static-body></a-plane>
  <a-sky id="sky" color="#88dffe"></a-sky>
  <a-entity id="castle" position="0 0 -28">
    <a-box color="#444" width="16" height="10" depth="16" position="0 5 0" shadow="cast:true" static-body></a-box>
    <a-text value="Dark Evil Castle" color="#fff" position="-4 12 -2" scale="3 3 3"></a-text>
  </a-entity>
  <a-entity id="mountains"></a-entity>
  <a-entity id="trees"></a-entity>
  <a-entity id="bushes"></a-entity>
  <a-entity id="boulders"></a-entity>
  <a-entity id="npc-group" position="0 0 -6">
    <a-box id="npc" color="#FFD700" position="0 1 0" depth="0.6" height="2" width="1.2" class="clickable" shadow="cast:true" static-body></a-box>
    <a-text value="Forest Elder (G to talk)" position="-1.6 2.6 0" color="#fff" align="center"></a-text>
  </a-entity>
  <a-entity id="villager-far" position="28 0 14">
    <a-box color="#a7e0a0" position="0 1 0" depth="0.7" height="2" width="1.2" shadow="cast:true" static-body></a-box>
    <a-text value="Villager" color="#fff" position="-1.2 2.6 0" scale="2 2 2"></a-text>
  </a-entity>
  <a-entity id="shop-house" position="20 0 17">
    <a-box width="3" depth="3" height="0.1" position="0 0 0" color="#8b5a2b"></a-box>
    <a-box width="3" depth="0.1" height="1.2" position="0 0.65 -1.45" color="#cfa07f"></a-box>
    <a-box width="3" depth="0.1" height="1.2" position="0 0.65 1.45" color="#cfa07f"></a-box>
    <a-box width="0.1" depth="3" height="1.2" position="-1.45 0.65 0" color="#cfa07f"></a-box>
    <a-box width="0.1" depth="3" height="1.2" position="1.45 0.65 0" color="#cfa07f"></a-box>
    <a-cone radius-bottom="2" radius-top="0.1" height="0.8" position="0 2.1 0" rotation="0 0 0" color="#8b1f1f"></a-cone>
    <a-entity id="shop-villager" position="0 0.25 0.7">
      <a-box color="#FFD700" position="0 1 0" depth="0.6" height="2" width="1.2"></a-box>
      <a-image src="#villagerImg" position="0 2.1 0" width="0.7" height="0.7"></a-image>
      <a-text value="Shop: G to buy/sell" color="#fff" position="-1.7 2.6 0" scale="1.6 1.6 1.6"></a-text>
    </a-entity>
  </a-entity>
  <a-entity id="collectibles"></a-entity>
  <a-entity id="enemies"></a-entity>
  <a-circle id="pond1" radius="1.2" color="#2aa3ff" position="-6 0.01 -10" rotation="-90 0 0" opacity="0.9" class="clickable" static-body></a-circle>
  <a-circle id="pond2" radius="1.4" color="#2aa3ff" position="6 0.01 -14" rotation="-90 0 0" opacity="0.9" class="clickable" static-body></a-circle>
  <a-entity id="player" position="0 1.6 2">
    <a-entity id="camera" camera look-controls="pointerLockEnabled: true" position="0 0 0"></a-entity>
  </a-entity>
</a-scene>

<script>
// ========== STATE & CONFIG =========
const state = {
  hp:100, hpMax:100,
  stamina:100, staminaMax:100,
  mana:60, manaMax:60,
  hydration:100, food:100,
  xp:0, xpMax:100, level:1,
  equipped:'', // 'stone-axe' or 'wood-staff'
  spells:[{id:'spark',name:'Spark',charges:0,max:3,dmg:15,cost:5}],
  knownSpells:new Set(['spark']),
  quest:'Talk to the Forest Elder',
  inventory:{ stick:0, rock:0, mushroom:0, potion:0, water:0, 'wood-staff':0, 'stone-axe':0, planks:0, house:0, ruby:0, fireball:0, 'ruby-necklace':0 },
  isDead:false
};
const shopItems = [
  {id:'food', name:'Food', price:3},
  {id:'armour', name:'Armour', price:7}
];
const CONFIG = {
  WALK_SPEED: 2.2,
  SPRINT_SPEED: 3.8,
  SPRINT_DRAIN_RATE: 15,
  STAM_REGEN_RATE: 8,
  ENEMY_WALK_SPEED: 1.5,
  ENEMY_AGGRO_RANGE: 8,
  ENEMY_ATTACK_RANGE: 2.5,
  ENEMY_ATTACK_COOLDOWN: 1.5,
  ENEMY_HEALTH: 60,
  ENEMY_DAMAGE: 8,
  ENEMY_ITEM_DROP_CHANCE: 0.6, // Increased to 60%
  ENEMY_ITEM_DROP_TYPE: 'ruby', // The type of item to drop
  ENEMY_ITEM_DROP_AMOUNT: 2,    // Increased to 2 items per drop
  ENEMY_XP: 25,
  TREE_CHOP_DAMAGE: 12,
  TREE_HP: 30,
  MINING_ROCK_DAMAGE: 10,
  MINING_ROCK_HP: 40,
  GRAVITY: -9.8,
  JUMP_SPEED: 5.2,
  PLAYER_GROUND_Y: 1.6,
  FIREBALL_MANA_COST: 18,
  CLIMB_VELOCITY: 3.8,
  BUILD_MODE_RANGE: 10,
  BUILD_MODE_OFFSET_Y: -0.5,
  ENEMY_MIN_SPAWN_DIST: 12,
  PLAYER_MELEE_RANGE: 2.2,
  PLAYER_MELEE_COOLDOWN: 0.6,
  PLAYER_MELEE_BASE_DAMAGE: 10,

  // Respawn Timers (in seconds)
  RESPAWN_DELAY_SHORT: 120, // 2 minutes for small items
  RESPAWN_DELAY_MEDIUM: 180, // 3 minutes for medium items
  RESPAWN_DELAY_LARGE: 300, // 5 minutes for larger/complex items
};

// Global object to manage respawn timers
const respawnTimers = {};
const activeResources = new Set(); // To keep track of currently spawned items

// Function to spawn a single resource item
function spawnResource(type, pos) {
  const resource = spawnCollectible(type, pos); // Use existing spawn function
  if (resource) {
    activeResources.add(resource);
    // Schedule respawn
    let delay = CONFIG.RESPAWN_DELAY_SHORT;
    if (type === 'tree' || type === 'boulder' || type === 'bush') { // Assign delays based on type
      delay = CONFIG.RESPAWN_DELAY_LARGE;
    }
    scheduleRespawn(type, pos, delay);
  }
}

// Function to schedule a respawn for a resource
function scheduleRespawn(type, pos, delay) {
  // Create a unique key for each potential spawn point to avoid conflicts
  // Using a simple string concatenation with fixed precision for position
  const timerKey = `${type}-${pos.x.toFixed(2)}x${pos.z.toFixed(2)}`;

  if (respawnTimers[timerKey]) clearTimeout(respawnTimers[timerKey]); // Clear if already scheduled

  respawnTimers[timerKey] = setTimeout(() => {
    // Before spawning, check if an item of this type already exists at the location (e.g., picked up before timer expired)
    // This check is basic; a more robust system might check bounding boxes.
    let itemAlreadyPresent = false;
    activeResources.forEach(res => {
      if (res && res.__type === type && Math.hypot(res.object3D.position.x - pos.x, res.object3D.position.z - pos.z) < 0.5) {
        itemAlreadyPresent = true;
      }
    });

    if (!itemAlreadyPresent) {
      spawnResource(type, pos);
    }
    delete respawnTimers[timerKey]; // Clean up timer after execution
  }, delay * 1000);
}


// ========== UTILITY FUNCTIONS =========
function getGroundYAt(x,z){
  const origin = new THREE.Vector3(x, 12, z);
  const dir = new THREE.Vector3(0, -1, 0);
  const ray = new THREE.Raycaster(origin, dir, 0, 30);
  const staticNodes = [...document.querySelectorAll('[static-body]')].map(n=>n.object3D);
  const hits = ray.intersectObjects(staticNodes, true);
  if(hits.length) return hits[0].point.y;
  return 0;
}
function rayFromCam(distance = Infinity){
  const cam = document.querySelector('#camera').object3D;
  const origin = new THREE.Vector3();
  cam.getWorldPosition(origin);
  const direction = new THREE.Vector3(0, 0, -1).applyQuaternion(cam.getWorldQuaternion(new THREE.Quaternion()));
  return new THREE.Raycaster(origin, direction, 0, distance);
}
function getTargetEntity(){
  const ray = rayFromCam(20);
  const entities = [...document.querySelectorAll('.clickable'), ...document.querySelectorAll('.tree'), ...document.querySelectorAll('[data-boulder]')];
  const hits = ray.intersectObjects(entities.map(e => e.object3D), true);
  if(hits.length > 0) return hits[0].object.el;
  return null;
}

// ========== FLOATING TEXT ==========
function showFloatingText(msg, pos, color='#fff') {
  const txt = document.createElement('a-text');
  txt.setAttribute('value', msg);
  txt.setAttribute('color', color);
  txt.setAttribute('position', `${pos.x} ${pos.y+1.4} ${pos.z}`);
  txt.setAttribute('scale', '2 2 2');
  txt.setAttribute('align', 'center');
  txt.setAttribute('side', 'double');
  document.querySelector('a-scene').appendChild(txt);
  setTimeout(() => { txt.parentNode && txt.parentNode.removeChild(txt); }, 1100);
}

// ========== WORLD SPAWNS =========
function ringMountains(){
  const ring=[
    [-100,-40],[-75,-75],[-40,-105],[0,-115],[40,-105],[75,-75],[100,-40],
    [100, 40],[75, 75],[40,105],[0,115],[-40,105],[-75,75],[-100,40]
  ];
  const root=document.querySelector('#mountains');
  ring.forEach((p,i)=>{
    const [x,z]=p;
    const h=14+Math.random()*6, r=14+Math.random()*5;
    const m=document.createElement('a-cone');
    m.setAttribute('color', i%2? '#585858':'#4e4e4e');
    m.setAttribute('position', `${x} ${h/2} ${z}`);
    m.setAttribute('radius-bottom', r.toFixed(2));
    m.setAttribute('radius-top', '0.2');
    m.setAttribute('height', h.toFixed(2));
    m.setAttribute('static-body','');
    root.appendChild(m);
  });
}
function spawnTree(x,z,hp=30){
  const ent=document.createElement('a-entity'); ent.setAttribute('position',`${x} 0 ${z}`); ent.classList.add('tree'); ent.setAttribute('static-body','');
  const trunk=document.createElement('a-cylinder'); trunk.setAttribute('height','2'); trunk.setAttribute('radius','0.25'); trunk.setAttribute('color','#8B5A2B'); trunk.setAttribute('position','0 1 0'); trunk.setAttribute('material','src:#bark; roughness:1');
  const crown=document.createElement('a-entity');
  const colors=['#0b6b2e','#0f7f39','#0a5f25'];
  for(let i=0;i<6;i++){ const s=document.createElement('a-sphere'); s.setAttribute('radius',0.8+Math.random()*0.45); s.setAttribute('color',colors[i%colors.length]); s.setAttribute('material','src:#leaf; roughness:1'); s.setAttribute('position',`${(Math.random()-.5)*1.0} ${1.6+Math.random()*0.7} ${(Math.random()-.5)*1.0}`); crown.appendChild(s); }
  ent.appendChild(trunk); ent.appendChild(crown);
  ent.__data={hp};
  document.querySelector('#trees').appendChild(ent);
  activeResources.add(ent); // Add to active resources
  // Schedule respawn for trees (longer delay)
  scheduleRespawn('tree', {x:parseFloat(x), z:parseFloat(z)}, CONFIG.RESPAWN_DELAY_LARGE);
}

function spawnBush(x,z){
  const e=document.createElement('a-entity'); e.setAttribute('position',`${x} 0 ${z}`); e.setAttribute('static-body','');
  for(let i=0;i<6;i++){ const s=document.createElement('a-sphere'); s.setAttribute('radius',0.35+Math.random()*0.25); s.setAttribute('color',i%2?'#126b34':'#0f7f39'); s.setAttribute('material','src:#leaf; roughness:1'); s.setAttribute('position',`${(Math.random()-.5)*0.9} ${0.35+Math.random()*0.2} ${(Math.random()-.5)*0.9}`); e.appendChild(s); }
  document.querySelector('#bushes').appendChild(e);
  activeResources.add(e);
  // Schedule respawn for bushes (medium delay)
  scheduleRespawn('bush', {x:parseFloat(x), z:parseFloat(z)}, CONFIG.RESPAWN_DELAY_MEDIUM);
}

function spawnBoulder(x,z){
  const e=document.createElement('a-entity'); e.setAttribute('position',`${x} 0 ${z}`); e.setAttribute('data-boulder',''); e.setAttribute('static-body','');
  const s=document.createElement('a-sphere'); s.setAttribute('radius',0.65+Math.random()*0.3); s.setAttribute('color','#7a7a7a'); s.setAttribute('position','0 0.65 0');
  e.appendChild(s); e.__data={hp:CONFIG.MINING_ROCK_HP};
  document.querySelector('#boulders').appendChild(e);
  activeResources.add(e);
  // Schedule respawn for boulders (medium delay)
  scheduleRespawn('boulder', {x:parseFloat(x), z:parseFloat(z)}, CONFIG.RESPAWN_DELAY_MEDIUM);
}
ringMountains();
// Call seedBasics which now uses spawnResource
seedBasics();

// ========== COLLECTIBLES ==========
// spawnCollectible function remains mostly the same, but now spawnResource will call it and manage respawns.
function spawnCollectible(type,pos){
  const itemData = { // Item type, associated icon ID, and scale
    stick: {icon:'icon-stick', scale: 0.2}, rock: {icon:'icon-rock', scale: 0.2}, mushroom: {icon:'icon-mushroom', scale: 0.2},
    potion: {icon:'icon-potion', scale: 0.2}, water: {icon:'icon-water', scale: 0.2}, 'wood-staff': {icon:'icon-wood-staff', scale: 0.4},
    'stone-axe': {icon:'icon-stone-axe', scale: 0.3}, planks: {icon:'icon-planks', scale: 0.2}, house: {icon:'icon-house', scale: 0.5},
    ruby: {icon:'icon-ruby', scale: 0.25}, 'ruby-necklace': {icon:'icon-ruby-necklace', scale: 0.3}
  };
  const halfHeight = (itemData[type]?.scale || 0.2) / 2;
  const groundY = getGroundYAt(pos.x, pos.z);
  const spawnY = groundY + halfHeight + 0.002;

  const e=document.createElement('a-entity'); e.setAttribute('position',`${pos.x} ${spawnY} ${pos.z}`); e.__type=type;

  if(type === 'house'){ // Special case for building
    e.setAttribute('geometry', {primitive: 'box', width: 4, height: 3, depth: 4});
    e.setAttribute('material', {src: '#houseTex', opacity: 0.5, transparent: true});
    e.classList.add('house-blueprint');
    e.setAttribute('static-body','');
    document.querySelector('#collectibles').appendChild(e);
    return e;
  }

  // Basic visual representation for other items
  if(type==='stick') {
    e.innerHTML=`<a-box color="#7a522a" depth="0.05" height="0.15" width="0.6" position="0 ${halfHeight} 0"></a-box>`;
  } else if(type==='rock') {
    e.innerHTML=`<a-sphere color="#777" radius="${halfHeight*1.1}" position="0 ${halfHeight} 0"></a-sphere>`;
  } else if(type==='mushroom') {
    e.innerHTML=`<a-cylinder color="#cfa07f" height="0.18" radius="0.05" position="0 0.09 0"></a-cylinder><a-sphere color="#ff3154" radius="0.15" position="0 0.22 0"></a-sphere>`;
  } else if(type==='potion') {
    e.innerHTML=`<a-cylinder color="#d45e5e" height="0.5" radius="0.15" position="0 ${halfHeight} 0"></a-cylinder>`;
  } else if(type==='water') {
    e.innerHTML=`<a-cylinder color="#3bb4ff" height="0.8" radius="0.2" position="0 ${halfHeight} 0"></a-cylinder>`;
  } else if(type==='stone-axe') {
    e.innerHTML=`<a-box color="#888" depth="0.2" height="0.6" width="0.15" position="0 ${halfHeight*1.5} 0"></a-box>`;
  } else if(type==='wood-staff') {
    e.innerHTML=`<a-cylinder color="#6c4f2a" height="1.2" radius="0.05" position="0 ${halfHeight} 0"></a-cylinder>`;
  } else if(type==='planks') {
    e.innerHTML=`<a-box color="#d2a679" depth="0.03" height="0.2" width="0.8" position="0 ${halfHeight} 0"></a-box>`;
  } else if(type==='ruby') {
    e.innerHTML = `<a-sphere color="#e8006f" radius="${halfHeight}" position="0 ${halfHeight} 0"></a-sphere>`;
  } else if (type === 'ruby-necklace') {
    e.innerHTML = `<a-entity geometry="primitive:torus; radius:0.15; radius-tubular-start:0.05; radius-tubular-end:0.05;" material="color: #e8006f; shader: flat; emissive: #e8006f;" rotation="90 0 0"></a-entity>`;
  }
  e.setAttribute('dynamic-body',`mass:0.2;shape:${type=='stick'||type=='planks'||type=='house'?'box':type=='mushroom'?'box':'sphere'};linearDamping:0.9;angularDamping:0.9;allowSleep:true;`);
  document.querySelector('#collectibles').appendChild(e);
  return e;
}

// Initial seeding of resources
function seedBasics(){
  for(let i=0;i<7;i++) spawnResource('stick',{x:(Math.random()*12-6),z:(Math.random()*12-6)});
  for(let i=0;i<5;i++) spawnResource('rock',{x:(Math.random()*12-6),z:(Math.random()*12-6)});
  for(let i=0;i<4;i++) spawnResource('mushroom',{x:(Math.random()*12-6),z:(Math.random()*12-6)});
}


// ========== ENEMIES ==========
const enemiesRoot=document.querySelector('#enemies');
let activeEnemies = [];
function updateEnemyCount(){ document.getElementById('enemyCount').textContent=activeEnemies.length; }

function createEnemy(x,z){
  const nx = parseFloat(x);
  const nz = parseFloat(z);
  const e=document.createElement('a-entity'); e.setAttribute('position',`${nx} 0.9 ${nz}`); e.classList.add('enemy');
  const body=document.createElement('a-sphere'); body.setAttribute('radius','0.5'); body.setAttribute('color','#ff5c5c'); body.setAttribute('shadow','cast:true');
  const eyeL=document.createElement('a-sphere'); eyeL.setAttribute('radius','0.07'); eyeL.setAttribute('color','#fff'); eyeL.setAttribute('position','-0.15 0.12 0.45');
  const eyeR=document.createElement('a-sphere'); eyeR.setAttribute('radius','0.07'); eyeR.setAttribute('color','#fff'); eyeR.setAttribute('position','0.15 0.12 0.45');
  const pupilL=document.createElement('a-sphere'); pupilL.setAttribute('radius','0.03'); pupilL.setAttribute('color','#000'); pupilL.setAttribute('position','-0.15 0.12 0.52');
  const pupilR=document.createElement('a-sphere'); pupilR.setAttribute('radius','0.03'); pupilR.setAttribute('color','#000'); pupilR.setAttribute('position','0.15 0.12 0.52');
  const hpText=document.createElement('a-text'); hpText.setAttribute('value','HP: 60'); hpText.setAttribute('position','0 1.2 0'); hpText.setAttribute('align','center'); hpText.setAttribute('color','#fff'); hpText.setAttribute('scale','1.2 1.2 1.2');
  e.appendChild(body); e.appendChild(eyeL); e.appendChild(eyeR); e.appendChild(pupilL); e.appendChild(pupilR); e.appendChild(hpText);
  e.setAttribute('kinematic-body','');
  e.__data={
    hp:CONFIG.ENEMY_HEALTH, alive:true, aggro:false,
    vx:0, vz:0,
    hpText:hpText, cooldown:0, dmg: CONFIG.ENEMY_DAMAGE, burning:0,
    wanderTarget: { x: nx + (Math.random()-0.5)*5, z: nz + (Math.random()-0.5)*5 },
    awarded:false
  };
  enemiesRoot.appendChild(e);
  activeEnemies.push(e);
  return e;
}

function spawnEnemies(count, minDist){
  const p=document.querySelector('#player').object3D.position;
  for(let i=0; i<count; i++){
    let x,z,tries=0, ok=false;
    while(!ok && tries<40){
      x=(Math.random()*80-40); z=(Math.random()*60-30); tries++;
      const d=Math.hypot(x-p.x,z-p.z);
      if(d>=minDist) ok=true;
    }
    if(ok) createEnemy(x.toFixed(2), z.toFixed(2));
  }
  updateEnemyCount();
}

// ========== IMPROVED ENEMY DEATH =================
function onEnemyDeath(e, source){
  if(!e.__data || e.__data.awarded) return;
  e.__data.awarded = true;
  e.__data.alive = false;
  e.setAttribute('visible', false);

  // XP reward
  state.xp += CONFIG.ENEMY_XP;
  logInfo(`Gained ${CONFIG.ENEMY_XP} XP for defeating an enemy.`);
  checkLevelUp();

  // Show floating XP
  const pos = e.object3D.position;
  showFloatingText(`+${CONFIG.ENEMY_XP} XP`, pos, '#39ffb6');

  // Item drop(s)
  let droppedItem = false;
  if (Math.random() < CONFIG.ENEMY_ITEM_DROP_CHANCE) {
    for(let i=0; i < CONFIG.ENEMY_ITEM_DROP_AMOUNT; i++) {
      // Use spawnResource for dropping loot to enable potential future respawning of specific loot types
      spawnResource(CONFIG.ENEMY_ITEM_DROP_TYPE, {x:pos.x, z:pos.z});
      droppedItem = true;
    }
  }
  if (droppedItem) showFloatingText('Loot dropped!', pos, '#e8006f'); // You can customize this message!

  setTimeout(()=>{ if(e.parentNode) e.parentNode.removeChild(e); }, 500);
  updateEnemyCount();
  refreshUI();
}

// ================== ENEMY AI ==================
// Aggro only if provoked, not proximity
function updateEnemies(dt){
  const playerPos = document.querySelector('#player').object3D.position;
  activeEnemies = activeEnemies.filter(e => e.parentNode);
  for (const e of activeEnemies) {
    if (!e.__data.alive) continue;
    const enemyPos = e.object3D.position;
    const distToPlayer = Math.hypot(enemyPos.x - playerPos.x, enemyPos.z - playerPos.z);

    // Only chase if provoked (aggro set by attack)
    if (e.__data.aggro && distToPlayer < CONFIG.ENEMY_AGGRO_RANGE) {
      // Already provoked, keep chasing if in range
      e.__data.aggro = true;
    }

    if (e.__data.aggro) {
      if (distToPlayer > CONFIG.ENEMY_ATTACK_RANGE) {
        const angle = Math.atan2(playerPos.z - enemyPos.z, playerPos.x - enemyPos.x);
        e.__data.vx = Math.cos(angle) * CONFIG.ENEMY_WALK_SPEED;
        e.__data.vz = Math.sin(angle) * CONFIG.ENEMY_WALK_SPEED;
      } else {
        e.__data.vx = 0; e.__data.vz = 0;
        if (e.__data.cooldown <= 0) {
          e.__data.cooldown = CONFIG.ENEMY_ATTACK_COOLDOWN;
          // damage player
          if (!state.isDead) {
            state.hp -= e.__data.dmg;
            if (state.hp < 0) state.hp = 0;
            refreshUI();
            const damageFlash = document.getElementById('damage-flash');
            damageFlash.style.opacity = '0.8';
            setTimeout(() => damageFlash.style.opacity = '0', 150);
            logInfo(`Took ${e.__data.dmg} damage!`);
            if(state.hp <= 0) handlePlayerDeath();
          }
        }
      }
    } else {
      const wanderDist = Math.hypot(enemyPos.x - e.__data.wanderTarget.x, enemyPos.z - e.__data.wanderTarget.z);
      if (wanderDist < 1.0) {
        e.__data.wanderTarget.x = enemyPos.x + (Math.random()-0.5)*5;
        e.__data.wanderTarget.z = enemyPos.z + (Math.random()-0.5)*5;
      }
      const angle = Math.atan2(e.__data.wanderTarget.z - enemyPos.z, e.__data.wanderTarget.x - enemyPos.x);
      e.__data.vx = Math.cos(angle) * CONFIG.ENEMY_WALK_SPEED * 0.4;
      e.__data.vz = Math.sin(angle) * CONFIG.ENEMY_WALK_SPEED * 0.4;
    }
    if (e.__data.cooldown > 0) e.__data.cooldown -= dt;
    enemyPos.x += e.__data.vx * dt;
    enemyPos.z += e.__data.vz * dt;
    e.setAttribute('position', `${enemyPos.x} ${enemyPos.y} ${enemyPos.z}`);
    if (e.__data.hpText) {
      e.__data.hpText.setAttribute('value','HP: '+Math.max(0,Math.round(e.__data.hp)));
      e.__data.hpText.setAttribute('position','0 1.2 0');
    }
  }
}

// ========== UI/REFRESH ==========
const invGrid = document.getElementById('inv-grid');
const craftingList = document.getElementById('craft-list');

function updateRubyBar(){ document.getElementById('rubyCount').textContent = state.inventory.ruby || 0; }

// Function to get item icon URL from assets
function getItemIconUrl(itemType) {
  const assetElement = document.querySelector(`img#icon-${itemType}`);
  return assetElement ? assetElement.src : 'https://cdn-icons-png.flaticon.com/512/184/184400.png'; // Generic fallback icon
}

// Function to render the inventory slots in the backpack
function renderInventorySlots() {
  invGrid.innerHTML = ''; // Clear existing slots
  const maxSlots = 36; // Example: 6x6 grid

  for (let i = 0; i < maxSlots; i++) {
    const slot = document.createElement('div');
    slot.classList.add('slot');
    slot.dataset.index = i; // Store index for potential future use

    // Check if an item should be displayed in this slot
    const inventoryItems = Object.entries(state.inventory).filter(([type, count]) => count > 0);
    if (i < inventoryItems.length) {
      const [itemType, quantity] = inventoryItems[i];
      slot.innerHTML = `
        <img src="${getItemIconUrl(itemType)}" alt="${itemType}">
        <div class="qty">${quantity}</div>
      `;
    }
    invGrid.appendChild(slot);
  }
}

// Call this whenever the inventory might have changed (pickup, craft, etc.)
function updateInventoryDisplay() {
  renderInventorySlots();
}

function logInfo(message) {
  const infolog = document.getElementById('infolog');
  const messageElement = document.createElement('div');
  messageElement.textContent = message;
  infolog.appendChild(messageElement);
  if (infolog.children.length > 18) {
    infolog.removeChild(infolog.children[0]);
  }
  infolog.scrollTop = infolog.scrollHeight;
}

// XP & Level up
function checkLevelUp(){
  while(state.xp >= state.xpMax){
    state.xp -= state.xpMax;
    state.level++;
    state.xpMax = Math.round(state.xpMax * 1.25);
    state.hpMax += 8;
    state.staminaMax += 5;
    state.manaMax += 5;
    state.hp = state.hpMax;
    state.mana = state.manaMax;
    logInfo(`Leveled up! Now level ${state.level}.`);
  }
  refreshUI();
}

function refreshUI(){
  document.getElementById('hpBar').style.width=(state.hp/state.hpMax*100)+'%';
  document.getElementById('stamBar').style.width=(state.stamina/state.staminaMax*100)+'%';
  document.getElementById('manaBar').style.width=(state.mana/state.manaMax*100)+'%';
  document.getElementById('hpText').textContent=`${Math.round(state.hp)}/${state.hpMax}`;
  document.getElementById('stamText').textContent=`${Math.round(state.stamina)}/${state.staminaMax}`;
  document.getElementById('manaText').textContent=`${Math.round(state.mana)}/${state.manaMax}`;
  document.getElementById('hydration').textContent=`${Math.round(state.hydration)}%`;
  document.getElementById('food').textContent=`${Math.round(state.food)}%`;
  document.getElementById('xp').textContent=state.xp;
  document.getElementById('xpMax').textContent=state.xpMax;
  document.getElementById('level').textContent=state.level;
  document.getElementById('quest').textContent=state.quest;
  document.getElementById('equipped').textContent=state.equipped? (state.equipped==='wood-staff'?'Wood Staff':'Stone Axe') : 'None';
  document.getElementById('xp_small').textContent = state.xp;
  updateRubyBar();
  updateEnemyCount();
  document.getElementById('status').textContent = state.isDead ? 'Dead' : (player.__grounded ? (sprinting ? 'Sprinting' : 'Idle') : 'In Air');
  updateInventoryDisplay(); // Ensure inventory is shown correctly
}


// ========== START BUTTON ==========
let gameStarted = false;
let enemiesSpawned = false;
let lastFrameTime = performance.now();

document.getElementById('start-btn').onclick = () => {
  if (gameStarted) return;
  document.getElementById('intro').style.display='none';
  gameStarted = true;
  refreshUI(); // Initial UI refresh

  const sceneEl = document.querySelector('a-scene');
  function doSpawn() {
    if (enemiesSpawned) return;
    spawnEnemies(22, CONFIG.ENEMY_MIN_SPAWN_DIST);
    enemiesSpawned = true;
    updateEnemyCount();
  }
  if (!sceneEl.hasLoaded) {
    sceneEl.addEventListener('loaded', doSpawn, { once: true });
  } else { doSpawn(); }

  lastFrameTime = performance.now();
  requestAnimationFrame(gameLoop);
};

// ========== PLAYER MOVEMENT & PHYSICS ==========
const player=document.getElementById('player'), cameraEl=document.getElementById('camera');
let moveDir={f:false,b:false,l:false,r:false}, sprinting=false;
player.__speed = CONFIG.WALK_SPEED; player.__velY = 0; player.__grounded = true;
let buildModeActive = false;
let currentBuildingPreview = null;
let entitiesInScene = new Set();

function setSpeed(){ player.__speed = sprinting ? CONFIG.SPRINT_SPEED : CONFIG.WALK_SPEED; }
function manageStamina(dt) {
  if (sprinting) {
    state.stamina -= CONFIG.SPRINT_DRAIN_RATE * dt;
    if (state.stamina < 0) {
      state.stamina = 0;
      sprinting = false;
      setSpeed();
      logInfo("Ran out of stamina!");
    }
  } else {
    state.stamina += CONFIG.STAM_REGEN_RATE * dt;
    if (state.stamina > state.staminaMax) {
      state.stamina = state.staminaMax;
    }
  }
  state.stamina = Math.max(0, Math.min(state.staminaMax, state.stamina));
  refreshUI();
}

// CLIMBING SUPPORT
function startClimbAtHit(hit) {
  if (!hit) return false;
  let rootObj = hit.object;
  while (rootObj.parent && rootObj.parent.type !== 'Scene') {
    rootObj = rootObj.parent;
  }
  const box = new THREE.Box3().setFromObject(rootObj);
  if (!box || box.isEmpty && !box.isEmpty()) { // Check for valid bounding box
    return false;
  }
  const topY = box.max.y;
  const hitPoint = hit.point.clone();
  const margin = 0.15;
  // Ensure the horizontal target position is within the object's bounds
  const targetX = Math.max(box.min.x + margin, Math.min(box.max.x - margin, hitPoint.x));
  const targetZ = Math.max(box.min.z + margin, Math.min(box.max.z - margin, hitPoint.z));
  const currentFeetY = player.object3D.position.y;
  const desiredFeetY = topY + CONFIG.PLAYER_GROUND_Y;

  if (desiredFeetY <= currentFeetY + 0.01) { // Already at or above the top
    logInfo("Already at or above the object's top.");
    return false;
  }
  player.__climbing = {
    active: true,
    targetTopY: topY,
    targetPos: { x: targetX, z: targetZ },
    sourceHitEl: (hit.object && hit.object.el) || null
  };
  player.__grounded = false;
  player.__velY = 0;
  logInfo("Climbing...");
  return true;
}

// KEY HANDLING
document.addEventListener('keydown',e=>{
  if(!gameStarted) return;
  if(state.isDead) return; // disable inputs when dead
  if(e.key==='Shift'){ sprinting=true; setSpeed(); }
  if(e.key==='w'||e.key==='W') moveDir.f=true;
  if(e.key==='s'||e.key==='S') moveDir.b=true;
  if(e.key==='a'||e.key==='A') moveDir.l=true;
  if(e.key==='d'||e.key==='D') moveDir.r=true;
  if(e.code==='Space' && gameStarted){
    e.preventDefault();
    if(player.__grounded){
      player.__velY = CONFIG.JUMP_SPEED;
      player.__grounded = false;
      logInfo("Jump!");
    }
  }
  if(e.key && e.key.toLowerCase()==='c'){
    if(!player.__grounded){
      logInfo("Can't start climbing while in the air.");
    } else {
      const raycaster = rayFromCam(2.0);
      const staticObjs = [...document.querySelectorAll('[static-body]')].filter(el => !el.classList.contains('building')); // Avoid climbing buildings
      const hits = raycaster.intersectObjects(staticObjs.map(el => el.object3D), true);
      if(hits.length > 0){
        const firstHit = hits[0];
        const didStart = startClimbAtHit(firstHit);
        if(!didStart) logInfo("No climbable top found or already above the top.");
      } else {
        logInfo("No object in front to climb.");
      }
    }
  }
  if(e.key.toLowerCase()==='b'){
    buildModeActive = !buildModeActive;
    if(buildModeActive) {
      logInfo("Build mode enabled. Press 'B' to exit. Left-click to place.");
      showBuildingPreview('house');
    } else {
      hideBuildingPreview();
    }
  }
});
document.addEventListener('keyup',e=>{
  if(!gameStarted) return;
  if(state.isDead) return;
  if(e.key==='Shift'){ sprinting=false; setSpeed(); }
  if(e.key==='w'||e.key==='W') moveDir.f=false;
  if(e.key==='s'||e.key==='S') moveDir.b=false;
  if(e.key==='a'||e.key==='A') moveDir.l=false;
  if(e.key==='d'||e.key==='D') moveDir.r=false;
});

// Mouse click for building placement and attacks
let playerAttackCooldown = 0;

document.addEventListener('mousedown', (e) => {
  if(!gameStarted) return;
  if(state.isDead) return;
  if (e.button === 0) { // Left click
    if (buildModeActive) {
      e.preventDefault();
      if ((state.inventory.house || 0) > 0) {
        placeBuilding('house');
      } else {
        showPrompt("You need to craft a house first!");
      }
      return;
    }
    meleeAttack();
  }
});

document.addEventListener('mousedown',e=>{
  if(!gameStarted) return;
  if(state.isDead) return;
  if(e.button === 2){ // Right click
    if(state.equipped === 'wood-staff' && state.knownSpells.has('fireball') && (state.inventory.fireball||0)>0 && state.mana >= CONFIG.FIREBALL_MANA_COST){
      shootFireball();
    }
  }
});

// MELEE ATTACK
function meleeAttack(){
  if(playerAttackCooldown > 0) return;
  playerAttackCooldown = CONFIG.PLAYER_MELEE_COOLDOWN;
  const cam = cameraEl.object3D;
  const camPos = new THREE.Vector3().setFromMatrixPosition(cam.matrixWorld);
  const dir = new THREE.Vector3(0,0,-1).applyQuaternion(cam.quaternion).normalize();
  let anyHit = false;
  for(const e of enemiesRoot.children){
    if(!e.__data || !e.__data.alive) continue;
    const ep = e.object3D.position.clone();
    const toEnemy = ep.clone().sub(camPos);
    const dist = toEnemy.length();
    if(dist <= CONFIG.PLAYER_MELEE_RANGE){
      const forwardDot = dir.dot(toEnemy.normalize());
      if(forwardDot > 0.7){ // roughly in front
        anyHit = true;
        // damage calculation
        let dmg = CONFIG.PLAYER_MELEE_BASE_DAMAGE;
        if(state.equipped === 'stone-axe') dmg += 18;
        else if(state.equipped === 'wood-staff') dmg += 6;
        e.__data.hp -= dmg;
        e.__data.aggro = true; // AGGRO ON HIT!
        e.__data.hpText.setAttribute('value','HP: '+Math.max(0,Math.round(e.__data.hp)));
        logInfo(`Hit enemy for ${dmg} damage.`);
        // small knockback
        e.object3D.position.x += dir.x * 0.2;
        e.object3D.position.z += dir.z * 0.2;
        if(e.__data.hp <= 0 && e.__data.alive){
          onEnemyDeath(e, 'melee');
          logInfo("Enemy defeated!");
        }
        break; // melee hits one enemy
      }
    }
  }
  if(!anyHit){
    logInfo("You swing and hit nothing.");
  }
  refreshUI();
}

// Attack cooldown ticking
setInterval(()=> { if(playerAttackCooldown>0) playerAttackCooldown = Math.max(0, playerAttackCooldown - 0.05); }, 50);

// ========== GAME LOOP ==========
function gameLoop(now){
  const dt = Math.min(0.05, (now - lastFrameTime) / 1000);
  lastFrameTime = now;

  if(gameStarted && !state.isDead){
    if(player.__climbing && player.__climbing.active){
      const pos = player.object3D.position;
      const tp = player.__climbing.targetPos;
      const targetY = player.__climbing.targetTopY + CONFIG.PLAYER_GROUND_Y;
      const dx = tp.x - pos.x;
      const dz = tp.z - pos.z;
      const distXZ = Math.hypot(dx, dz);
      if(distXZ > 0.001){
        const moveXZ = Math.min(distXZ, CONFIG.CLIMB_VELOCITY * dt);
        pos.x += (dx / distXZ) * moveXZ;
        pos.z += (dz / distXZ) * moveXZ;
      }
      if(pos.y < targetY){
        pos.y = Math.min(pos.y + CONFIG.CLIMB_VELOCITY * dt, targetY);
      }
      player.object3D.position.set(pos.x, pos.y, pos.z);
      player.setAttribute('position', `${pos.x} ${pos.y} ${pos.z}`);
      const arrivedVertically = pos.y >= targetY - 0.001;
      const arrivedHorizontally = distXZ <= 0.06;
      if(arrivedVertically && arrivedHorizontally){
        player.object3D.position.set(tp.x, targetY, tp.z);
        player.setAttribute('position', `${tp.x} ${targetY} ${tp.z}`);
        player.__climbing.active = false;
        player.__grounded = true;
        player.__velY = 0;
        logInfo("Reached the top and stood on it.");
      }
      manageStamina(dt);
      updateEnemies(dt);
      updateBuildingPreview();
      requestAnimationFrame(gameLoop);
      return;
    }

    const yaw = cameraEl.object3D.rotation.y;
    const forward = new THREE.Vector3(-Math.sin(yaw),0,-Math.cos(yaw));
    const right   = new THREE.Vector3(-forward.z,0,forward.x);
    let dir = new THREE.Vector3();
    if(moveDir.f) dir.add(forward);
    if(moveDir.b) dir.sub(forward);
    if(moveDir.l) dir.sub(right);
    if(moveDir.r) dir.add(right);
    if(dir.lengthSq()>0){ dir.normalize().multiplyScalar(player.__speed*dt); player.object3D.position.add(dir); }

    player.__velY += CONFIG.GRAVITY * dt;
    player.object3D.position.y += player.__velY * dt;
    if(player.object3D.position.y <= CONFIG.PLAYER_GROUND_Y){
      player.object3D.position.y = CONFIG.PLAYER_GROUND_Y;
      player.__velY = 0;
      player.__grounded = true;
    } else { player.__grounded = false; }

    manageStamina(dt);
    updateEnemies(dt);
    updateBuildingPreview();
  }

  // general ticks (cooldowns, regen)
  if(gameStarted && !state.isDead){
    // mana regen small
    state.mana = Math.min(state.manaMax, state.mana + 8 * dt);
    refreshUI();
  }
  requestAnimationFrame(gameLoop);
}

// ========== FIREBALL SPELL LOGIC ==========
function shootFireball(){
  state.inventory.fireball -= 1;
  state.mana -= CONFIG.FIREBALL_MANA_COST;
  refreshUI();
  const cam = cameraEl.object3D;
  const pos = new THREE.Vector3().setFromMatrixPosition(cam.matrixWorld);
  const dir = new THREE.Vector3(0,0,-1).applyQuaternion(cam.quaternion).normalize();
  const fb = document.createElement('a-sphere');
  fb.setAttribute('radius','0.23');
  fb.setAttribute('color','#ff7f1f');
  fb.setAttribute('position',`${pos.x} ${pos.y} ${pos.z}`);
  fb.setAttribute('shadow','cast:true');
  document.querySelector('a-scene').appendChild(fb);
  let t=0;
  let hit = false;
  function anim(){
    if(t>1.5 || hit){ fb.parentNode&&fb.parentNode.removeChild(fb); return; }
    t+=0.05;
    pos.add(dir.clone().multiplyScalar(0.48));
    fb.setAttribute('position',`${pos.x} ${pos.y} ${pos.z}`);
    for(const e of enemiesRoot.children){
      if(!e.__data||!e.__data.alive) continue;
      const ep = e.object3D.position;
      if(Math.hypot(ep.x-pos.x,ep.y-pos.y,ep.z-pos.z)<1.1){
        hit = true;
        e.__data.hp -= 36;
        e.__data.aggro = true; // AGGRO ON HIT!
        e.__data.hpText.setAttribute('value','HP: '+Math.max(0,Math.round(e.__data.hp)));
        if(Math.random()<0.45){
          e.__data.burning = 5;
          e.setAttribute('color','#ffb133');
        }
        if(e.__data.hp<=0 && e.__data.alive){
          onEnemyDeath(e, 'fireball');
          logInfo("Enemy defeated!");
        }
        break;
      }
    }
    setTimeout(anim, 50);
  }
  anim();
}

// ========== BURNING DAMAGE ==========
setInterval(()=>{
  for(const e of enemiesRoot.children){
    if(e.__data && e.__data.burning>0){
      e.__data.hp -= 2;
      e.__data.burning -= 1;
      e.__data.hpText.setAttribute('value','HP: '+Math.max(0,Math.round(e.__data.hp)));
      if(e.__data.burning<=0) e.setAttribute('color','#ff5c5c');
      if(e.__data.hp<=0 && e.__data.alive){
        onEnemyDeath(e, 'burn');
      }
    }
  }
},1000);

// ========== PLAYER DEATH & RESPAWN ==========
const deathOverlay = document.getElementById('deathOverlay');
const respawnCountdownEl = document.getElementById('respawnCountdown');

function handlePlayerDeath(){
  if(state.isDead) return;
  state.isDead = true;
  logInfo("You have been defeated!");
  // Show death overlay and disable inputs
  deathOverlay.style.display = 'flex';
  let countdown = 4;
  respawnCountdownEl.textContent = `Respawning in ${countdown}...`;
  // optionally drop some items on death
  const droppedRubies = Math.floor((state.inventory.ruby || 0) * 0.3);
  if(droppedRubies>0){
    state.inventory.ruby -= droppedRubies;
    const p = player.object3D.position;
    // spawn some rubies around player
    for(let i=0;i<droppedRubies;i++){
      spawnResource('ruby',{x: p.x + (Math.random()-0.5)*1.5, z: p.z + (Math.random()-0.5)*1.5});
    }
  }
  refreshUI();
  const countdownInterval = setInterval(()=>{
    countdown--;
    if(countdown>0) respawnCountdownEl.textContent = `Respawning in ${countdown}...`;
    else {
      clearInterval(countdownInterval);
      respawnPlayer();
    }
  }, 1000);
}

function respawnPlayer(){
  // reset player position and some stats
  player.object3D.position.set(0, CONFIG.PLAYER_GROUND_Y, 2);
  player.setAttribute('position', `0 ${CONFIG.PLAYER_GROUND_Y} 2`);
  state.isDead = false;
  state.hp = Math.max(1, Math.round(state.hpMax * 0.6));
  state.mana = Math.min(state.manaMax, Math.round(state.manaMax * 0.5));
  state.stamina = Math.min(state.staminaMax, Math.round(state.staminaMax * 0.5));
  deathOverlay.style.display = 'none';
  logInfo("You have respawned.");
  refreshUI();
}

// ========== SHOP & INTERACTION ==========
function interactTalk(){
  if(state.isDead) return false;
  const p = player.object3D.position;
  const elder = document.querySelector('#npc-group').object3D.position;
  const villager = document.querySelector('#villager-far').object3D.position;
  const shopHouse = document.querySelector('#shop-house').object3D.position;
  if(Math.hypot(elder.x-p.x,elder.z-p.z)<2.2){
    if(state.quest==='Talk to the Forest Elder'){
      state.quest='Collect 5 sticks for the Elder';
      logInfo("Elder: 'The forest needs help. Gather 5 sticks for me.'");
    }else if(state.quest==='Collect 5 sticks for the Elder'){
      if((state.inventory.stick||0)>=5){
        state.inventory.stick-=5; state.quest='Complete! Elder teaches Fireball.';
        if(!state.knownSpells.has('fireball')){
          state.knownSpells.add('fireball');
          state.spells.push({id:'fireball',name:'Fireball',charges:2,max:2,dmg:36,cost:CONFIG.FIREBALL_MANA_COST});
          state.inventory.fireball += 2;
          logInfo("Elder: 'Thank you! Here is a token of my gratitude and knowledge.'");
        } else {
          logInfo("Elder: 'You have already brought the sticks. Well done.'");
        }
      } else {
        logInfo("Elder: 'You have not yet gathered the sticks.'");
      }
    }
    refreshUI(); return true;
  }
  if(Math.hypot(villager.x-p.x, villager.z-p.z)<2.2){
    logInfo('Villager: "Stay safe out there!"'); return true;
  }
  if(Math.abs(p.x-shopHouse.x)<2 && Math.abs(p.z-shopHouse.z)<2){ interactShop(); return true; }
  logInfo('No one to talk to'); return false;
}
function interactPickup(){
  if(state.isDead) return false;
  const p=player.object3D.position;
  let nearest=null, nd=9e9;
  // Iterate through active resources to find the closest pickup
  activeResources.forEach(res => {
    if (!res || !res.parentNode) return; // Skip if resource is invalid or removed
    const cp=res.object3D.position; const d=Math.hypot(cp.x-p.x, cp.z-p.z);
    if(d<1.6 && d<nd){ nd=d; nearest=res; }
  });

  if(nearest){
    const t=nearest.__type;
    if(t === 'ruby') {
      state.inventory.ruby = (state.inventory.ruby||0)+1;
      // Remove from active resources and trigger respawn
      activeResources.delete(nearest);
      nearest.parentNode&&nearest.parentNode.removeChild(nearest);
      refreshUI();
      logInfo('Picked up a ruby! ✨');
      return true;
    }
    state.inventory[t]=(state.inventory[t]||0)+1;
    // Remove from active resources and trigger respawn
    activeResources.delete(nearest);
    nearest.parentNode&&nearest.parentNode.removeChild(nearest);
    refreshUI();
    logInfo(`Picked up a ${t}.`);
    return true;
  }
  // Check ponds for water
  for(let i=0; i<document.querySelectorAll('a-circle.clickable').length; i++){
    const pond=document.querySelectorAll('a-circle.clickable')[i];
    const po=pond.object3D.position; const d=Math.hypot(po.x-p.x, po.z-p.z);
    if(d<2){
      state.inventory.water=(state.inventory.water||0)+1;
      // Water is not a collectible entity, so no respawn logic here unless you make it one.
      refreshUI();
      logInfo('Collected some water. 💧');
      return true;
    }
  }
  return false;
}
function interactShop(){
  const p = player.object3D.position;
  const shopHouseEntity = document.querySelector('#shop-house');
  if(!shopHouseEntity) { showPrompt('No shop found'); return false; }
  const shopHousePos = shopHouseEntity.object3D.position;
  if(Math.abs(p.x - shopHousePos.x) < 2.2 && Math.abs(p.z - shopHousePos.z) < 2.2){
    let msg = 'Shop - Buy with Rubies:<br>';
    shopItems.forEach(item=>{
      msg += `${item.name} (${item.price} rubies) <button onclick="window.buyShopItem('${item.id}')">Buy</button><br>`;
    });
    msg += '<br><button onclick="window.openSellMenu()">Sell Items</button>';
    showPrompt(msg);
    return true;
  }
  showPrompt('No shop nearby');
  return false;
}
window.buyShopItem = function(id){
  const item = shopItems.find(i=>i.id===id);
  if(!item) return;
  if((state.inventory.ruby||0) < item.price){
    showPrompt('Not enough rubies!'); return;
  }
  state.inventory.ruby -= item.price;
  if(id === 'food') {
    state.food = Math.min(100, state.food + 50);
    logInfo('Ate some food. 🍎');
  }
  if(id === 'armour') {
    state.hpMax += 20;
    state.hp = state.hpMax;
    logInfo('Equipped better armor! 🛡️');
  }
  showPrompt('Thanks for your purchase!'); refreshUI();
};
window.openSellMenu = function(){
  let msg = 'Sell Items for Rubies:<br>';
  Object.keys(state.inventory).forEach(k=>{
    if(state.inventory[k]>0 && k!=='ruby' && k !== 'fireball'){ // Don't sell fireballs or rubies
      msg += `${k} x${state.inventory[k]} <button onclick="window.sellItem('${k}')">Sell</button><br>`;
    }
  });
  if(msg==='Sell Items for Rubies:<br>') msg += 'No items to sell!';
  showPrompt(msg);
};
window.sellItem = function(id){
  if(!state.inventory[id]||id==='ruby') return;
  state.inventory[id]--;
  state.inventory.ruby = (state.inventory.ruby||0)+1;
  showPrompt('Sold '+id+' for 1 ruby');
  window.openSellMenu();
  refreshUI();
};
function showPrompt(html){
  const p = document.getElementById('prompt');
  p.innerHTML = html;
  p.style.display = 'block';
  setTimeout(()=>{p.style.display='none';}, 2600);
}
document.addEventListener('keydown',e=>{
  if(!gameStarted) return;
  if(state.isDead) return;
  if(e.key.toLowerCase()==='e') interactPickup();
  if(e.key.toLowerCase()==='g') interactTalk();
});

// ========== UPGRADE STATS LOGIC ==========
function upgradeStat(statName, cost) {
  if (state.xp >= cost) {
    state.xp -= cost;
    if (statName === 'hp') {
      state.hpMax += 10;
      state.hp = state.hpMax;
      logInfo("HP increased! ❤️");
    } else if (statName === 'stamina') {
      state.staminaMax += 5;
      state.stamina = state.staminaMax;
      logInfo("Stamina increased! 💨");
    } else if (statName === 'mana') {
      state.manaMax += 8;
      state.mana = state.manaMax;
      logInfo("Mana increased! 🪄");
    }
    refreshUI();
  } else {
    showPrompt("Not enough XP to upgrade!");
  }
}
document.getElementById('up-hp').addEventListener('click', () => upgradeStat('hp', 50));
document.getElementById('up-stam').addEventListener('click', () => upgradeStat('stamina', 30));
document.getElementById('up-mana').addEventListener('click', () => upgradeStat('mana', 30));

// ========== BACKPACK HOTBAR FUNCTIONALITY ==========
const backpack = document.getElementById('backpack');
const moreBtn = document.getElementById('more-btn');
const closeBpBtn = document.getElementById('close-bp');

// Render crafting recipes based on current inventory
function renderCraftingRecipes() {
  craftingList.innerHTML = ''; // Clear existing list
  recipes.forEach(recipe => {
    const recipeElement = document.createElement('div');
    recipeElement.classList.add('craft-row');

    let canCraft = true;
    let materialString = getMaterialCostString(recipe.materials);
    for (const [material, count] of Object.entries(recipe.materials)) {
      if ((state.inventory[material] || 0) < count) {
        canCraft = false;
        break;
      }
    }

    recipeElement.innerHTML = `
      <div class="craft-left">
        <img src="${getItemIconUrl(recipe.id)}" alt="${recipe.name}">
        <span>${recipe.name}</span>
      </div>
      <button onclick="craftItem('${recipe.id}')" class="ui-clickable" style="${!canCraft ? 'opacity: 0.5; cursor: not-allowed;' : ''}">
        Craft (${materialString})
      </button>
    `;
    craftingList.appendChild(recipeElement);
  });
}

function getMaterialCostString(materials) {
  return Object.entries(materials).map(([item, count]) => `${item} x${count}`).join(', ');
}

function craftItem(itemId) {
  const recipe = recipes.find(r => r.id === itemId);
  if (!recipe) return;

  let canCraft = true;
  for (const [material, count] of Object.entries(recipe.materials)) {
    if ((state.inventory[material] || 0) < count) {
      canCraft = false;
      break;
    }
  }

  if (canCraft) {
    for (const [material, count] of Object.entries(recipe.materials)) {
      state.inventory[material] -= count;
    }
    state.inventory[itemId] = (state.inventory[itemId] || 0) + 1;
    logInfo(`Crafted ${recipe.name}!`);
    refreshUI(); // Refresh UI to update inventory and counts
  } else {
    showPrompt(`Not enough materials to craft ${recipe.name}.`);
  }
}


moreBtn.addEventListener('click', () => {
    backpack.classList.add('open');
    logInfo("Opened backpack.");
    renderCraftingRecipes(); // Update recipe display when opening backpack
    updateInventoryDisplay(); // Ensure inventory display is fresh
});
closeBpBtn.addEventListener('click', () => {
  backpack.classList.remove('open');
  logInfo("Closed backpack.");
});


// ========== CRAFTING RECIPES DEFINITION ==========
const recipes = [
  // --- Original Recipes ---
  { id: 'planks', name: 'Planks', materials: { stick: 2, rock: 1 } },
  { id: 'wood-staff', name: 'Wood Staff', materials: { stick: 3 } },
  { id: 'stone-axe', name: 'Stone Axe', materials: { stick: 3, rock: 3 } },
  { id: 'potion', name: 'Health Potion', materials: { mushroom: 2, water: 1 } },
  { id: 'house', name: 'House', materials: { planks: 10, rock: 5 } },
  // --- NEW RECIPE EXAMPLE: Ruby Necklace ---
  { id: 'ruby-necklace', name: 'Ruby Necklace', materials: { ruby: 2, planks: 1 } },
  // --- Add more recipes here as needed ---
];

// Ensure recipes are rendered when the game starts
document.getElementById('start-btn').addEventListener('click', renderCraftingRecipes);


// ========== BUILDING SYSTEM ==========
let placedBuildings = [];

function showBuildingPreview(buildingType) {
  if (currentBuildingPreview) {
    currentBuildingPreview.parentNode.removeChild(currentBuildingPreview);
  }
  currentBuildingPreview = document.createElement('a-entity');
  currentBuildingPreview.setAttribute('id', 'build-preview');
  // Use a default box geometry; specific assets can be added later
  currentBuildingPreview.setAttribute('geometry', { primitive: 'box', width: 4, height: 3, depth: 4 });
  currentBuildingPreview.setAttribute('material', { src: '#houseTex', opacity: 0.4, transparent: true });
  currentBuildingPreview.setAttribute('position', '0 100 0'); // Initial off-screen position
  currentBuildingPreview.style.display = 'block';
  document.querySelector('a-scene').appendChild(currentBuildingPreview);
}

function hideBuildingPreview() {
  if (currentBuildingPreview) {
    currentBuildingPreview.style.display = 'none';
  }
}

function updateBuildingPreview() {
  if (!buildModeActive || !currentBuildingPreview) return;
  const ray = rayFromCam(CONFIG.BUILD_MODE_RANGE);
  const groundY = getGroundYAt(ray.origin.x, ray.origin.z);
  const previewPos = {
    x: ray.origin.x,
    y: groundY + CONFIG.BUILD_MODE_OFFSET_Y + 1.5, // Adjust Y based on object's height center
    z: ray.origin.z
  };
  const collision = checkBuildingCollision(previewPos);
  if (collision) {
    currentBuildingPreview.setAttribute('material', 'opacity', 0.2); // Indicate invalid placement
  } else {
    currentBuildingPreview.setAttribute('material', 'opacity', 0.4); // Indicate valid placement
  }
  currentBuildingPreview.setAttribute('position', `${previewPos.x} ${previewPos.y} ${pos.z}`);
}

function checkBuildingCollision(pos) {
  const buildingSize = { width: 4, height: 3, depth: 4 }; // Assumed size of the house
  const buffer = 0.2; // Small buffer to avoid precision issues

  // Check if the building would be too low
  if (pos.y < CONFIG.PLAYER_GROUND_Y + buildingSize.height / 2) return true;

  const collisionRaycaster = new THREE.Raycaster();
  const halfSize = new THREE.Vector3(buildingSize.width / 2, buildingSize.height / 2, buildingSize.depth / 2);

  // Check collision points around the base and top center
  const testPoints = [
    new THREE.Vector3(pos.x - halfSize.x + buffer, pos.y, pos.z - halfSize.z + buffer),
    new THREE.Vector3(pos.x + halfSize.x - buffer, pos.y, pos.z - halfSize.z + buffer),
    new THREE.Vector3(pos.x - halfSize.x + buffer, pos.y, pos.z + halfSize.z - buffer),
    new THREE.Vector3(pos.x + halfSize.x - buffer, pos.y, pos.z + halfSize.z - buffer),
    new THREE.Vector3(pos.x, pos.y + halfSize.y - buffer, pos.z) // Check center top
  ];

  for (const testPoint of testPoints) {
    const origin = new THREE.Vector3(testPoint.x, 20, testPoint.z); // Ray starts high above
    const direction = new THREE.Vector3(0, -1, 0);
    collisionRaycaster.set(origin, direction, 0, 30); // Raycast downwards
    // Consider only static bodies that are not part of the preview itself
    const staticNodes = [...document.querySelectorAll('[static-body]')].map(el => el.object3D).filter(obj => obj && obj.el !== currentBuildingPreview);
    const hits = collisionRaycaster.intersectObjects(staticNodes, true);

    if (hits.length > 0) {
      // If a hit occurs and it's above the test point's intended Y position (with buffer)
      if (hits[0].point.y > testPoint.y - buffer) {
        return true; // Collision detected
      }
    }
  }
  return false; // No collision detected
}

function placeBuilding(buildingType) {
  if (!buildModeActive || !currentBuildingPreview || currentBuildingPreview.style.display === 'none') return;
  const pos = currentBuildingPreview.object3D.position;
  if (checkBuildingCollision({x: pos.x, y: pos.y, z: pos.z})) {
    showPrompt("Cannot place building here - collision detected!");
    return;
  }
  // Deduct materials - assuming 'house' is the only building for now
  if (state.inventory.house > 0) {
    state.inventory.house--;
    state.inventory.planks -= 10;
    state.inventory.rock -= 5;
  } else {
    showPrompt("You don't have a house blueprint!");
    return;
  }

  const house = document.createElement('a-entity');
  house.setAttribute('geometry', { primitive: 'box', width: 4, height: 3, depth: 4 });
  house.setAttribute('material', { src: '#houseTex', roughness: 1 });
  house.setAttribute('position', `${pos.x} ${pos.y} ${pos.z}`);
  house.setAttribute('static-body', '');
  house.classList.add('building'); // Add class for collision checks
  document.querySelector('a-scene').appendChild(house);
  entitiesInScene.add(house); // Track placed entities
  logInfo("House built!");
  refreshUI();
  hideBuildingPreview();
  buildModeActive = false; // Exit build mode after placing
}

document.addEventListener('DOMContentLoaded', () => {
  if (gameStarted) { // If game already started on load, ensure preview is handled
    showBuildingPreview('house');
    hideBuildingPreview();
  }
});

// ========== MISC ==========
// Initial seeding of resources and setup of initial timers
seedBasics();
// Initial UI setup when the page loads
refreshUI();
</script>
</body>
</html>

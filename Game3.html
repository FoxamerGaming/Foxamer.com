<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Geometry Dash</title>
    <style>
        canvas {
            display: block;
            margin: 0 auto;
            background: linear-gradient(black, darkblue);
        }
        #scoreboard {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-size: 20px;
        }
        #lastScore {
            position: absolute;
            top: 10px;
            right: 10px;
            color: white;
            font-size: 20px;
        }
    </style>
</head>
<body>
    <div id="scoreboard">Score: 0</div>
    <div id="lastScore">Last Score: 0</div>
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreboard = document.getElementById('scoreboard');
        const lastScore = document.getElementById('lastScore');

        const playerSize = 50;
        let playerPos = [100, canvas.height - playerSize];
        let playerVel = 0;
        const gravity = 1;
        let scrollSpeed = 5;
        let score = 0;
        let lastScoreValue = 0;
        let difficultyIncrease = 0.0005;
        let lastObstacleX = 0;
        let flip = false;
        let flipAngle = 0;
        const flipDuration = 200; // Duration of the flip animation in milliseconds
        let flipStartTime = 0;

        const obstacles = [];
        const platforms = [];

        function drawPlayer() {
            ctx.save();
            ctx.translate(playerPos[0] + playerSize / 2, playerPos[1] + playerSize / 2);
            if (flip) {
                const currentTime = Date.now();
                const elapsedTime = currentTime - flipStartTime;
                if (elapsedTime < flipDuration) {
                    flipAngle = (elapsedTime / flipDuration) * Math.PI;
                } else {
                    flipAngle = Math.PI;
                }
            } else {
                const currentTime = Date.now();
                const elapsedTime = currentTime - flipStartTime;
                if (elapsedTime < flipDuration) {
                    flipAngle = Math.PI - (elapsedTime / flipDuration) * Math.PI;
                } else {
                    flipAngle = 0;
                }
            }
            ctx.rotate(flipAngle);
            ctx.translate(-playerSize / 2, -playerSize / 2);

            ctx.fillStyle = 'white';
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(playerSize, 0);
            ctx.lineTo(playerSize, playerSize);
            ctx.lineTo(0, playerSize);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            // Draw eyes
            ctx.fillStyle = 'black';
            ctx.beginPath();
            ctx.arc(20, 20, 5, 0, Math.PI * 2);
            ctx.arc(30, 20, 5, 0, Math.PI * 2);
            ctx.fill();

            // Draw mouth
            ctx.beginPath();
            ctx.arc(25, 35, 5, 0, Math.PI);
            ctx.stroke();

            ctx.restore();
        }

        function drawObstacles() {
            ctx.fillStyle = 'red';
            obstacles.forEach(obstacle => {
                ctx.beginPath();
                ctx.moveTo(obstacle.x + obstacle.width / 2, obstacle.y);
                ctx.lineTo(obstacle.x, obstacle.y + obstacle.height);
                ctx.lineTo(obstacle.x + obstacle.width, obstacle.y + obstacle.height);
                ctx.closePath();
                ctx.fill();
                obstacle.x -= scrollSpeed;
            });
        }

        function drawPlatforms() {
            ctx.fillStyle = 'gray';
            platforms.forEach(platform => {
                ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
                platform.x -= scrollSpeed;
            });
        }

        function update() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawPlayer();
            drawObstacles();
            drawPlatforms();

            playerVel += gravity;
            playerPos[1] += playerVel;

            if (playerPos[1] + playerSize >= canvas.height) {
                playerPos[1] = canvas.height - playerSize;
                playerVel = 0;
                flip = false;
            }

            // Check for collisions with obstacles
            obstacles.forEach((obstacle, index) => {
                const spikeTipX = obstacle.x + obstacle.width / 2;
                const spikeTipY = obstacle.y;
                if (playerPos[0] < spikeTipX + 5 && playerPos[0] + playerSize > spikeTipX - 5 &&
                    playerPos[1] < spikeTipY + 5 && playerPos[1] + playerSize > spikeTipY - 5) {
                    lastScoreValue = score;
                    lastScore.innerText = `Last Score: ${lastScoreValue}`;
                    resetGame();
                }
                if (obstacle.x + obstacle.width < 0) {
                    obstacles.splice(index, 1);
                    score += 10;
                    scoreboard.innerText = `Score: ${score}`;
                }
            });

            // Check for collisions with platforms
            platforms.forEach((platform, index) => {
                if (playerPos[0] < platform.x + platform.width &&
                    playerPos[0] + playerSize > platform.x &&
                    playerPos[1] < platform.y + platform.height &&
                    playerPos[1] + playerSize > platform.y) {
                    playerPos[1] = platform.y - playerSize;
                    playerVel = 0;
                    flip = false;
                }
                if (playerPos[0] < platform.x + platform.width &&
                    playerPos[0] + playerSize > platform.x &&
                    playerPos[1] + playerSize > platform.y &&
                    playerPos[1] < platform.y) {
                    playerVel = 0;
                    playerPos[1] = platform.y + platform.height;
                }
                if (platform.x + platform.width < 0) {
                    platforms.splice(index, 1);
                }
            });

            // Add new obstacles and platforms
            if (Math.random() < 0.02 && obstacles.length < 3) {
                let newObstacleX;
                do {
                    newObstacleX = lastObstacleX + 400 + Math.random() * 300;
                } while (obstacles.some(obstacle => Math.abs(obstacle.x - newObstacleX) < 200));

                const newObstacle = {
                    x: newObstacleX,
                    y: canvas.height - 50,
                    width: 100,
                    height: 50
                };
                obstacles.push(newObstacle);
                lastObstacleX = newObstacle.x;
            }

            if (Math.random() < 0.02 && platforms.length < 3) {
                const newPlatform = {
                    x: canvas.width + Math.random() * 500,
                    y: Math.random() * (canvas.height / 2) + 50,
                    width: Math.random() * 150 + 50,
                    height: 20
                };
                platforms.push(newPlatform);
            }

            if (Math.random() < 0.02 && platforms.length < 3) {
                const newGroundPlatform = {
                    x: canvas.width + Math.random() * 500,
                    y: canvas.height - 150,
                    width: Math.random() * 150 + 50,
                    height: 20
                };
                platforms.push(newGroundPlatform);
            }

            // Increase difficulty over time
            scrollSpeed += difficultyIncrease;
            difficultyIncrease += 0.00001;

            requestAnimationFrame(update);
        }

        function resetGame() {
            playerPos = [100, canvas.height - playerSize];
            playerVel = 0;
            scrollSpeed = 5;
            score = 0;
            scoreboard.innerText = `Score: ${score}`;
            obstacles.length = 0;
            platforms.length = 0;
            lastObstacleX = 0;
            flip = false;
            flipAngle = 0;
        }

        document.addEventListener('keydown', (event) => {
            if (event.key === ' ' && playerVel === 0) {
                playerVel = -20;
                flip = true;
                flipStartTime = Date.now();
            }
        });

        update();
    </script>
</body>
</html>